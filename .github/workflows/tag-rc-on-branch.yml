name: RC Tagging

on:
  create:
  pull_request_target:
    types: [closed]
    branches: ['rc/v*.*.*.*']   # PR target branch must match rc/vx.x.x.x

permissions:
  contents: write

jobs:
  tag_on_branch_create:
    if: ${{ github.event_name == 'create' && github.event.ref_type == 'branch' && startsWith(github.event.ref, 'rc/') }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        env:
          BRANCH: ${{ github.event.ref }}           # e.g. rc/v1.2.3.4
        with:
          script: |
            const { owner, repo } = context.repo;
            const branch = process.env.BRANCH;
            if (!/^rc\/v\d+\.\d+\.\d+\.\d+$/.test(branch)) {
              core.setFailed(`Branch must be rc/vx.x.x.x. Got: ${branch}`);
              return;
            }
            const base = branch.replace(/^rc\//,'');      // v1.2.3.4
            const tag  = `${base}-rc1`;                   // v1.2.3.4-rc1
            const ref  = await github.rest.git.getRef({ owner, repo, ref: `heads/${branch}` });
            try {
              await github.rest.git.createRef({ owner, repo, ref: `refs/tags/${tag}`, sha: ref.data.object.sha });
              core.info(`Created ${tag}`);
            } catch (e) {
              if (e.status === 422) core.info(`${tag} exists, skipping`); else throw e;
            }

  bump_rc_on_pr_merge:
    if: ${{ github.event_name == 'pull_request_target' && github.event.pull_request.merged == true }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const baseRef = context.payload.pull_request.base.ref;   // rc/v1.2.3.4
            if (!/^rc\/v\d+\.\d+\.\d+\.\d+$/.test(baseRef)) {
              core.setFailed(`Target branch must be rc/vx.x.x.x. Got: ${baseRef}`);
              return;
            }
            const base = baseRef.replace(/^rc\//,'');                // v1.2.3.4

            // Merge commit SHA (works for merge/squash); fallback to base head
            let sha = context.payload.pull_request.merge_commit_sha;
            if (!sha) {
              const r = await github.rest.git.getRef({ owner, repo, ref: `heads/${baseRef}` });
              sha = r.data.object.sha;
            }

            // find existing vX.X.X.X-rcN tags
            const prefix = `tags/${base}-rc`;
            const refs = (await github.rest.git.listMatchingRefs({ owner, repo, ref: prefix })).data;

            // if already tagged at this sha, skip
            if (refs.some(r => r.object?.sha === sha)) {
              core.info(`A tag already points to ${sha.substring(0,7)}. Skipping.`);
              return;
            }

            const nums = refs
              .map(r => r.ref.replace(/^refs\/tags\//,''))
              .map(name => name.match(new RegExp(`^${base}-rc(\\d+)$`)))
              .filter(Boolean)
              .map(m => parseInt(m[1],10));

            const next = (nums.length ? Math.max(...nums) + 1 : 1);
            const tag  = `${base}-rc${next}`;
            await github.rest.git.createRef({ owner, repo, ref: `refs/tags/${tag}`, sha });
            core.info(`Created ${tag} -> ${sha.substring(0,7)}`);
