name: LogixPro Frontend CI Staging

on:
  push:
    branches:
      - staging
  pull_request:
    branches:
    - staging
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:

env:
  SCRIPTS_CHECKOUT_DIR: 'scripts'
  ARTIFACT_DIR: 'C:/buildArtifacts/LogixPro'

jobs:
  build:
    runs-on: windows-latest
    permissions:
      contents: read
    outputs:
      full_version: ${{ steps.versioning.outputs.full_version }}
      clean_version: ${{ steps.versioning.outputs.clean_version }}


    steps:
      - name: Checkout LogixPro Application Code
        uses: actions/checkout@v4
        with:
          repository: scotttech-enterprise64/LogixProFrontend
          ref: 'staging'
          path: ${{ env.APP_CHECKOUT_DIR }}
          fetch-depth: 0

      - name: Checkout Build Scripts
        uses: actions/checkout@v4
        with:
          repository: scotttechpickpro/JenkinsBuildAgent
          # TODO: Expire and add an new token
          token: ${{ secrets.PAT_TOKEN }}
          ref: 'main'
          path: ${{ env.SCRIPTS_CHECKOUT_DIR }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install dependencies
        run: |
          npm install -g @angular/cli
          npm install

      - name: Setup .NET SDK
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '8.0.414'

      - name: Run Pre-Build Scripts
        run: |
          $scriptsDir = "${{ github.workspace }}\${{ env.SCRIPTS_CHECKOUT_DIR }}\buildScripts\"
          powershell -File "${scriptsDir}PostSCMScript.ps1"
          powershell -File "${scriptsDir}CheckForDLLs.ps1"
        shell: pwsh

      - name: Calculate Version Number
        id: versioning
        working-directory: ${{ env.APP_CHECKOUT_DIR }}
        run: |
          # Get the latest git tag description
          $gitResult = git describe --tags $(git rev-list --tags --max-count=1)

          echo "Variable gitResult is $gitResult"

          # Clean the result to get a base version (e.g., "1.2.3")
          $cleanResult = ($gitResult.Trim() -replace '^v', '').Split('-')[0]

          echo "Variable cleanResult is $cleanResult"

          # Get the build number from GitHub Actions
          $buildNumber = "${{ github.run_number }}"

          # Construct the full version string by appending the suffix
          $fullVersion = "$cleanResult-RC$buildNumber"
          echo "Generated Version: $fullVersion"

          # Set the version as an output for subsequent steps
          echo "full_version=$fullVersion" >> $env:GITHUB_OUTPUT
          echo "clean_version=$cleanResult" >> $env:GITHUB_OUTPUT

        shell: pwsh

      - name: Build Application and Installer
        working-directory: ${{ env.APP_CHECKOUT_DIR }}
        run: |
          # Get the version calculated in the previous step
          $fullVersion = "${{ steps.versioning.outputs.full_version }}"
          Write-Output "Using version $fullVersion for the build."

          # Define paths
          $workspacePath = $env:GITHUB_WORKSPACE
          $tempPath = "C:\Temp\LogixProRCTemp"

          # Show directory files
          Write-Output "Directory"
          dir

          # Creating a nuget.config file
          $nugetConfigContent = @"
          <?xml version="1.0" encoding="utf-8"?>
          <configuration>
            <packageSources>
              <add key="nuget.org" value="https://api.nuget.org/v3/index.json" protocolVersion="3" />
              <add key="jfrog-private-peaklogix" value="https://peaklogix.jfrog.io/artifactory/api/nuget/peaklogix-nuget-dev-virtual" />
              <add key="jfrog-private-picklib-core" value="https://peaklogix.jfrog.io/artifactory/api/nuget/picklib-core-nuget-dev-local" />
            </packageSources>
            <packageSourceCredentials>
              <jfrog-private-peaklogix>
                <add key="Username" value="${{ secrets.JFROG_USERNAME }}" />
                <add key="ClearTextPassword" value="${{ secrets.JFROG_PASSWORD }}" />
              </jfrog-private-peaklogix>
              <jfrog-private-picklib-core>
                <add key="Username" value="${{ secrets.JFROG_USERNAME }}" />
                <add key="ClearTextPassword" value="${{ secrets.JFROG_PASSWORD }}" />
              </jfrog-private-picklib-core>
            </packageSourceCredentials>
          </configuration>
          "@
          $nugetConfigPath = Join-Path (Get-Location) "nuget.config"
          Set-Content -Path $nugetConfigPath -Value $nugetConfigContent
          
          $json = Get-Content -Path package.json | ConvertFrom-Json
          $json.version = "${{ steps.versioning.outputs.full_version }}"
          $json | ConvertTo-Json -Depth 20 | Set-Content -Path package.json

          cd build
          ./build.ps1
          
          # Find the output tarball and save its path
          $tarFile = (Get-ChildItem -Path ../output -Filter *.tgz | Select-Object -First 1).FullName
          Write-Host "Assets Tarball found at: $tarFile"
          echo "ASSETS_TAR=$tarFile" >> $env:GITHUB_ENV
        shell: powershell

      - name: Build Installer
        shell: powershell
        run: |
          # Debug
          Get-ChildItem -Path . -Filter "*.msi" -Recurse
          Get-ChildItem -Path . -Filter "appsettings.json" -Recurse

          # Creating a nuget.config file
          Write-Host "Creating a nuget.config file"
          $nugetConfigContent = @"
          <?xml version="1.0" encoding="utf-8"?>
          <configuration>
            <packageSources>
              <add key="nuget.org" value="https://api.nuget.org/v3/index.json" protocolVersion="3" />
              <add key="jfrog-private-peaklogix" value="https://peaklogix.jfrog.io/artifactory/api/nuget/peaklogix-nuget-dev-virtual" />
              <add key="jfrog-private-picklib-core" value="https://peaklogix.jfrog.io/artifactory/api/nuget/picklib-core-nuget-dev-local" />
            </packageSources>
            <packageSourceCredentials>
              <jfrog-private-peaklogix>
                <add key="Username" value="${{ secrets.JFROG_USERNAME }}" />
                <add key="ClearTextPassword" value="${{ secrets.JFROG_PASSWORD }}" />
              </jfrog-private-peaklogix>
              <jfrog-private-picklib-core>
                <add key="Username" value="${{ secrets.JFROG_USERNAME }}" />
                <add key="ClearTextPassword" value="${{ secrets.JFROG_PASSWORD }}" />
              </jfrog-private-picklib-core>
            </packageSourceCredentials>
          </configuration>
          "@

          # Creates the nuget.config in the current working directory
          Set-Content -Path "nuget.config" -Value $nugetConfigContent

          # Update appsettings.json
          $appSettingsPath = "server\LogixProServer\appsettings.json"
          (Get-Content $appSettingsPath) -replace '0.0.0', '${{ steps.versioning.outputs.full_version }}' | Set-Content $appSettingsPath

          # Restore and Build Installer
          cd server
          dotnet restore LogixProInstaller\LogixProServerInstaller.wixproj
          dotnet build LogixProInstaller\LogixProServerInstaller.wixproj -c Release /p:"Platform=x64;AssetsPackageFile=${{ env.ASSETS_TAR }}"

          $installerDir = "LogixProInstaller\bin\x64\Release\en-US"
          $msiFile = Get-ChildItem -Path $installerDir -Filter "*.msi" | Select-Object -First 1
          
          $newMsiName = "LogixProInstaller_${{ steps.versioning.outputs.full_version }}.msi"
          Rename-Item -Path $msiFile.FullName -NewName $newMsiName
          $fullInstallerPath = Join-Path $msiFile.Directory.FullName $newMsiName
          echo "INSTALLER_PATH=$fullInstallerPath" >> $env:GITHUB_ENV

      - name: Upload Installer Artifact
        uses: actions/upload-artifact@v4
        with:
          name: LogixPro-Installer-${{ steps.versioning.outputs.full_version }}
          path: ${{ env.INSTALLER_PATH }}   

  deploy:
    runs-on: ubuntu-latest
    needs: build

    # Grant permissions
    permissions:
      id-token: write
      contents: read

    steps:
      - name: Checkout Build Scripts
        uses: actions/checkout@v4
        with:
          repository: scotttechpickpro/JenkinsBuildAgent
          token: ${{ secrets.PAT_TOKEN }}
          ref: 'main'
          path: ${{ env.SCRIPTS_CHECKOUT_DIR }}

      # Download artifacts
      - name: 'Downloading build artifacts'
        uses: actions/download-artifact@v4
        with:
          name: LogixPro-Installer-${{ needs.build.outputs.full_version }}

      # Login to Azure
      - name: 'Login to Azure'
        uses: azure/login@v1
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # Upload files to Azure Blob Storage
      - name: 'Upload to Azure Blob Storage'
        uses: azure/CLI@v2
        with:
          inlineScript: |
            # Delete all existing artifacts
            echo "Clearing old artifacts..."
            az storage blob list \
              --container-name 'artifacts' \
              --account-name "gaintegration" \
              --auth-mode login \
              --prefix 'logixpro/' \
              --query '[].name' -o tsv |
            while read -r blob_name; do
              if [ -n "$blob_name" ]; then
                echo "Deleting blob: $blob_name"
                az storage blob delete --container-name 'artifacts' --name "$blob_name" --account-name "gaintegration" --auth-mode login
              fi
            done

            # Upload latest artifacts
            az storage blob upload-batch \
              --account-name "gaintegration" \
              --auth-mode login \
              --source "." \
              --destination 'artifacts/logixpro' \
              --overwrite
            echo "Upload completed"

      - name: 'Download and Install on Azure VM'
        uses: azure/CLI@v2
        with:
          inlineScript: |
            az vm run-command invoke \
              --name "vm-test-dev2-eus" \
              --resource-group "rg-stage-214-eus" \
              --command-id RunPowerShellScript \
              --script '
                $azPath = "C:\Program Files (x86)\Microsoft SDKs\Azure\CLI2\wbin\az.cmd"
                $destinationDir = "C:\artifacts"
                $azureCliCachePath = "$env:USERPROFILE\.azure"

                # Create directory
                if (-not (Test-Path $destinationDir)) {
                  Write-Host "Destination directory not found. Creating..."
                  New-Item -ItemType Directory -Path $destinationDir
                } else{
                  Write-Host "Clearing older artifacts..."
                  Remove-Item -Path "$destinationDir\*" -Recurse -Force
                }

                # Check if Azure CLI is already installed
                if (-not (Test-Path $azPath)) {
                  Write-Host "Azure CLI not found on VM. Installing..."
                  $msiPath = "$env:TEMP\AzureCLI.msi"
                  Invoke-WebRequest -Uri "https://aka.ms/installazurecliwindows" -OutFile $msiPath
                  Start-Process "msiexec.exe" -ArgumentList "/i `"$msiPath`" /quiet" -Wait
                  Write-Host "Installation complete."
                } else {
                  Write-Host "Azure CLI is already installed on the VM."
                }

                # Login to Azure
                & $azPath login --identity
                if ($LASTEXITCODE -ne 0) {
                  Write-Error "ERROR: Failed to log in to Azure with managed identity."
                  exit 1
                }
                
                Write-Host "Listing blobs in the artifacts container..."
                & $azPath storage blob list --container-name "artifacts" --account-name "gaintegration" --auth-mode login
                
                # Download the artifacts
                Write-Host "Downloading artifacts..."
                
                # Get a list of all blobs with the 'logixpro/' prefix
                $blobList = & $azPath storage blob list --container-name "artifacts" --account-name "gaintegration" --prefix "logixpro/" --auth-mode login --query '[].name' -o tsv | Where-Object { $_ -like "*.msi" }

                # Loop through each blob name and download it individually
                foreach ($blob in $blobList) {
                    $fileName = Split-Path -Leaf $blob
                    $destinationFile = Join-Path $destinationDir $fileName
                    
                    Write-Host "Downloading blob: $blob to $destinationFile"
                    & $azPath storage blob download --container-name "artifacts" --name $blob --file $destinationFile --account-name "gaintegration" --auth-mode login
                    
                    if ($LASTEXITCODE -ne 0) {
                        Write-Error "ERROR: Failed to download blob: $blob"
                        exit 1
                    }
                }

                Write-Host "Download completed."

                # Find downloaded filename
                $msiFile = Get-ChildItem -Path $destinationDir -Filter "*.msi" | Select-Object -First 1

                if ($msiFile) {
                  Write-Host "Starting silent installation of $($msiFile.Name)..."
                  $arguments = "/i ""$($msiFile.FullName)"" /qn SERVER_URL=""https://logixpro.peaklogix.local"""
                  Start-Process msiexec.exe -ArgumentList $arguments -Wait

                  # Start and Verify Service
                  $serviceName = "PeakLogix.LogixPro"
                  Write-Host "Attempting to start and verify service: $serviceName"
                  Start-Service -Name $serviceName -ErrorAction SilentlyContinue
                  Write-Host "Waiting 20 seconds for the service to initialize..."
                  Start-Sleep -Seconds 20
                  # Check the service status
                  $service = Get-Service -Name $serviceName -ErrorAction SilentlyContinue

                  if ($service -and $service.Status -eq "Running") {
                      Write-Host "SUCCESS: Service ''$serviceName'' has started and is running."
                  } else {
                      Write-Error "FAILURE: Service ''$serviceName'' is not running. Current status: $($service.Status)"
                      exit 1
                  }

                  Write-Host "Installation command finished."
                } else {
                  Write-Error "ERROR: MSI installer file not found in $destinationDir\logixpro"
                  exit 1
                }

                Write-Host "Logixpro installation finished."
              '

      # Logout of Azure
      - name: 'Logout of Azure'
        if: always()
        run: |
          az logout
          az account clear
          